# xpTURN.Polyfill.Runtime

Runtime polyfill package for using C# 9·10·11 syntax (`record`, `init`, `required`, custom interpolated strings, etc.) in Unity as-is.

The .NET Standard 2.1 BCL used by Unity does not include the types required for the above syntax (`IsExternalInit`, `RequiredMemberAttribute`, etc.), so code generated by the compiler may fail to resolve them at runtime. This package provides the same namespace and type names for those APIs and, via its Editor module, supports applying `-langversion` in Player Settings and auto-configuring .csproj LangVersion.

## Provided types

| C# version | Feature | Types |
|------------|----------|--------|
| C# 9  | `init`-only setter | [IsExternalInit](./src/Polyfill/Assets/Polyfill/Runtime/Init/IsExternalInit.cs) |
| C# 10 | Custom interpolated string handler | [InterpolatedStringHandlerAttribute](./src/Polyfill/Assets/Polyfill/Runtime/InterpolatedString/InterpolatedStringHandlerAttribute.cs), [InterpolatedStringHandlerArgumentAttribute](./src/Polyfill/Assets/Polyfill/Runtime/InterpolatedString/InterpolatedStringHandlerArgumentAttribute.cs) |
| C# 11 | `required` member | [RequiredMemberAttribute](./src/Polyfill/Assets/Polyfill/Runtime/Required/RequiredMemberAttribute.cs) |
| C# 11 | Constructor satisfying `required` | [SetsRequiredMembersAttribute](./src/Polyfill/Assets/Polyfill/Runtime/Required/SetsRequiredMembersAttribute.cs) |
| C# 11 | Compiler feature requirement | [CompilerFeatureRequiredAttribute](./src/Polyfill/Assets/Polyfill/Runtime/Required/CompilerFeatureRequiredAttribute.cs) |

Runtime also includes interpolated string helpers such as `AppendInterpolatedStringHandler` for `StringBuilder`.

## Requirements

- Unity 2022.3.12f1 or later

## Installation

1. Open **Window > Package Manager**
2. Click **+** > **Add package from git URL...**
3. Enter:

```text
https://github.com/xpTURN/Polyfill.git?path=src/Polyfill/Assets/Polyfill
```

### Project settings (C# langversion)

When using advanced syntax such as `init`, `required`, or interpolated string handlers, you may need **Additional Compiler Arguments** and **.csproj LangVersion** applied.  
The **Editor** module of this package lets you apply or remove these settings via menu items and .csproj post-processing.

1. Run **Edit > Polyfill > Player Settings > Apply Additional Compiler Arguments -langversion (All Installed Platforms)**.
2. Settings are stored in **ProjectSettings** / **xpTURN.Polyfill.Settings.json**.

When applied:

- **Project Settings (Player > Additional Compiler Arguments)**  
  `-langversion:preview` is added for installed platforms (used by Unity build).
- **.csproj**  
  When Unity regenerates .csproj files, `<LangVersion>preview</LangVersion>` is **automatically** inserted so IDEs (Cursor, Visual Studio, OmniSharp, etc.) use it for C# 11 syntax support.

- Note: For Unity 2022.3.12f1 or later, creating a `csc.rsp` file is unnecessary.

To disable:

- Run **Edit > Polyfill > Player Settings > Remove Additional Compiler Arguments -langversion (All Installed Platforms)**.

## Usage examples

### init-only property (C# 9)

```csharp
public class Data
{
    public string Id { get; init; }
    public int Value { get; init; }
}

var d = new Data { Id = "a", Value = 1 };
```

### record (C# 9)

Works on top of the `init` polyfill. Supports value equality and `with` expressions.

```csharp
public record Point(int X, int Y);

var p = new Point(1, 2);
var q = p with { Y = 3 };  // Point(1, 3)
```

### required member (C# 11)

```csharp
public class Config
{
    public required string Name { get; set; }
    public required int Port { get; init; }

    [SetsRequiredMembers]
    public Config(string name, int port)
    {
        Name = name;
        Port = port;
    }
}
```

### Custom interpolated string (C# 10)

Use [InterpolatedStringHandlerAttribute](./src/Polyfill/Assets/Polyfill/Runtime/InterpolatedString/InterpolatedStringHandlerAttribute.cs) and [InterpolatedStringHandlerArgumentAttribute](./src/Polyfill/Assets/Polyfill/Runtime/InterpolatedString/InterpolatedStringHandlerArgumentAttribute.cs) to implement custom handlers.

Handler example:

```csharp
using System;
using System.Text;
using System.Runtime.CompilerServices;

namespace xpTURN.Polyfill.Samples.InterpolatedStringHandler
{
    [InterpolatedStringHandler]
    public ref struct XHandler
    {
        private static readonly StringBuilder _sb = new StringBuilder();
        public string GetString() => _sb.ToString();

        public XHandler(int literalLength, int formattedCount) => _sb.Clear();

        public void AppendLiteral(string value) => _sb.Append(value);
        public void AppendFormatted<T>(T value) => _sb.Append(value != null ? value.ToString() : "");
        public void AppendFormatted(string value) => _sb.Append(value);
        public void AppendFormatted(object value, int alignment = 0, string format = null) => _sb.Append(value != null ? value.ToString() : "");
        public void AppendFormatted<T>(T value, string format) => _sb.Append(value is IFormattable f ? f.ToString(format, null) : (value?.ToString() ?? ""));
    }
}
```

Logger example:

```csharp
using System;
using System.Text;
using System.Runtime.CompilerServices;

using UnityEngine;

using xpTURN.Polyfill.Samples.InterpolatedStringHandler;

namespace xpTURN.Polyfill.Samples;

public sealed class XLogger
{
    public static void Log([InterpolatedStringHandlerArgument] ref XHandler handler) =>
        Debug.Log(handler.GetString());

    public static void LogWarning([InterpolatedStringHandlerArgument] ref XHandler handler) =>
        Debug.LogWarning(handler.GetString());

    public static void LogError([InterpolatedStringHandlerArgument] ref XHandler handler) =>
        Debug.LogError(handler.GetString());

    public static void LogAssertion([InterpolatedStringHandlerArgument] ref XHandler handler) =>
        Debug.LogAssertion(handler.GetString());
}
```

Logger call:

```csharp
XLogger.Log($"Interpolated at time={Time.time:F2}, frame={Time.frameCount}");
```

Compiled result (ILSpy):

```csharp
XHandler handler = new XHandler(29, 2);
handler.AppendLiteral("Interpolated at time=");
handler.AppendFormatted(Time.time, "F2");
handler.AppendLiteral(", frame=");
handler.AppendFormatted(Time.frameCount);
XLogger.Log(ref handler);
```

- With the **above** compiled pattern, **runtime cost** and **GC** for interpolated strings are reduced.  
  Normal `$"…"` can allocate intermediate strings multiple times via `string.Format`/concatenation, and arguments passed as `params object[]` can **box** value types.  
  A custom handler is invoked generically as `AppendFormatted<T>(T value)`, so value types are passed without boxing; it appends literals and values in sequence (typically as a `ref struct`) and builds the final string only once at `Debug.Log(handler.GetString())`, keeping allocations and GC pressure low.

- The sample above is a minimal C# 10 custom interpolated string handler. For production, consider [ZLogger](https://github.com/Cysharp/ZLogger) or [ZString](https://github.com/Cysharp/ZString) on GitHub.

### MonoBehaviour and namespace in Unity

Use **block namespace** for MonoBehaviour scripts that are attached as components.  
With **file-scoped namespace** (`namespace xpTURN.Polyfill.Samples;`), Unity may fail to find the script class and show *"Can't add script component 'XXX' because the script class cannot be found"*.

- **Recommended (block)**  
  `namespace xpTURN.Polyfill.Samples { public class TestLogger : MonoBehaviour { ... } }`
- **Not recommended (file-scoped)**  
  `namespace xpTURN.Polyfill.Samples;` + `public class TestLogger : MonoBehaviour { ... }` — may not be recognized as a component

Plain classes (e.g. Config, XLogger) may use file-scoped namespace.

## License

The xpTURN.Polyfill code is under the Apache License, Version 2.0. See [LICENSE](./LICENSE.md) for details.

## Links

- **Changelog**: [CHANGELOG](./CHANGELOG.md)
- **License**: [LICENSE](./LICENSE.md)
- **Author**: [xpTURN](https://github.com/xpTURN)
